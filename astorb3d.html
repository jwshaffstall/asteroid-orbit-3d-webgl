<!DOCTYPE html>
<html lang="en">
<head>
    <title>astorb 3d</title>
    <meta name="viewport" content="width=device-width">
    <style>
        html, body
        {
            height: 100%;
            margin: 0;
            overflow: hidden; /* no page scrollbars */
        }

        body
        {
            font-family: monospace;
            background-color: white;
            color: black;

            /* Let the canvas take the remaining height. */
            display: flex;
            flex-direction: column;

            /* Fit exactly into the viewport. */
            height: 100vh;
            box-sizing: border-box;

            /* Internal spacing without affecting flex sizing like margins can. */
            padding: 4px;

            /* Allow children to shrink instead of overflowing. */
            min-height: 0;
        }

        h1
        {
            margin: 0;
            flex: 0 0 auto;
        }

        #astorb3dCanvas
        {
            width: 100%;

            /* Fill the remaining space between the header and the fixed-height areas. */
            flex: 1 1 auto;
            min-height: 0;

            background-color: pink;
            outline: none;

            /* Prevent inline-canvas whitespace affecting layout. */
            display: block;

            /* Ensure touch gestures are handled by the canvas. */
            touch-action: none;
        }
        #astorb3dCanvas:focus
        {
            outline: 2px solid #4CAF50;
        }
        #statusDisplay
        {
            padding: 5px;
            background-color: #333;
            color: #0f0;
            font-size: 12px;
            font-family: monospace;
            flex: 0 0 auto;
        }
        #controlBar
        {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            padding: 6px 0;
            flex: 0 0 auto;
        }
        #controlBar button
        {
            background-color: #222;
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 8px 14px;
            font-size: 14px;
            cursor: pointer;
            min-width: 90px;
        }
        #controlBar button:active
        {
            transform: translateY(1px);
        }
        #timeScaleLabel
        {
            font-size: 12px;
            color: #222;
        }
        @media (max-width: 640px)
        {
            #controlBar button
            {
                flex: 1 1 120px;
                font-size: 16px;
                padding: 10px 16px;
            }
        }
        #astorbLog
        {
            width: 100%;

            /* Fixed log area that scrolls instead of growing forever. */
            height: 160px;
            overflow-y: auto;

            background-color: lightgray;
            flex: 0 0 auto;
            min-height: 0;

            /* Keep long lines from forcing horizontal growth. */
            white-space: pre-wrap;
            word-break: break-word;
        }
    </style>
</head>
<body onload="astorb.onLoadBody()">
<h1>astorb 3d</h1>
<div id="controlBar">
    <button id="pauseButton" type="button">Pause</button>
    <button id="slowButton" type="button">Slow Down</button>
    <button id="fastButton" type="button">Speed Up</button>
    <button id="asteroidHalfButton" type="button">Half Asteroids</button>
    <button id="asteroidDoubleButton" type="button">Double Asteroids</button>
    <button id="depthBufferButton" type="button">Depth: --</button>
    <button id="renderColorButton" type="button">Color: --</button>
    <span id="timeScaleLabel">Speed: --</span>
    <span id="asteroidCountLabel">Asteroids: --</span>
</div>
<canvas id="astorb3dCanvas" tabindex="0">
    Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
</canvas>
<div id="statusDisplay">Status: Loading...</div>
<div id="astorbLog"></div>
<!-- <script src="scripts/js/libs/sylvester.src.js"></script> -->
<!-- <script src="scripts/js/libs/glUtils.js"></script> -->
<script src="scripts/js/libs/gl-matrix-min.js"></script>
<script src="scripts/js/libs/stats.min.js"></script>
<script src="scripts/js/astorb3d.js"></script>
<script type="x-shader/x-vertex" id="shader-vs">
    precision mediump float; // or lowp

    attribute float aSemimajorAxis;
    attribute float aEccentricity;
    attribute float aInclination;
    attribute float aArgumentOfPerihelion;
    attribute float aLongitudeOfAscendingNode;
    attribute float aMeanAnomaly;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform float time; // seconds

    varying float x;
    varying float y;
    varying float z;
    varying float vEccentricity;
    varying float vInclination;
    varying float vViewDistance;

    void main(void)
    {
        float semimajorAxis = aSemimajorAxis;
        float eccentricity = aEccentricity;
        float inclination = aInclination;
        float argumentOfPerihelion = aArgumentOfPerihelion;
        float longitudeOfAscendingNode = aLongitudeOfAscendingNode;
        float meanAnomaly = aMeanAnomaly;

        const float pi = 3.1415926535897932384626433832795;
        const float two_pi = 2.0 * pi;

        const float deg2rad = pi / 180.0;

        float a = semimajorAxis;
        float e = eccentricity;
        float i = inclination * deg2rad;
        float omega = argumentOfPerihelion * deg2rad;
        float sigma = longitudeOfAscendingNode * deg2rad;
        float M0 = meanAnomaly * deg2rad;

        const float standardGravitationalParameterSun = 3.96401599E-14; // AU^3/s^2
        const float muSun = standardGravitationalParameterSun;

        float n = sqrt(muSun / pow(a, 3.0));
        float M = mod(n * time + M0, two_pi);

        float E = M;  // Initialize E with mean anomaly for better convergence
        const int iterationCount = 30;
        for (int iteration = 0; iteration < iterationCount; iteration++)
        {
            E = E - (E - e*sin(E) - M)/(1.0 - e*cos(E));
        }
        float r = a * (1.0 - e*cos(E));
        float nu = 2.0 * atan(sqrt((1.0 + e)/(1.0 - e)) * tan(E/2.0));

        float theta = omega + nu;

        x = r * (cos(sigma)*cos(theta) - sin(sigma)*sin(theta)*cos(i));
        y = r * (sin(sigma)*cos(theta) + cos(sigma)*sin(theta)*cos(i));
        z = r * (sin(i)*sin(theta));

        vec4 mvPosition = uMVMatrix * vec4(x, y, z, 1.0);
        gl_Position = uPMatrix * mvPosition;
        vViewDistance = length(mvPosition.xyz);
        vEccentricity = eccentricity;
        vInclination = inclination;
        gl_PointSize = 2.0;
    }
</script>
<script type="x-shader/x-fragment" id="shader-fs">
    precision mediump float; // or lowp

    uniform int uColorMode;
    uniform float uFarPlaneAU;

    varying float x;
    varying float y;
    varying float z;
    varying float vEccentricity;
    varying float vInclination;
    varying float vViewDistance;

    void main(void)
    {
        vec3 color;
        if (uColorMode == 1)
        {
            // Normalize eccentricity (0 = circular, 1 = very eccentric)
            float normalizedEccentricity = clamp(vEccentricity / 0.4, 0.0, 1.0);
            // Normalize inclination (0 = ecliptic plane, 1 = highly inclined)
            float normalizedInclination = clamp(abs(vInclination) / 30.0, 0.0, 1.0);

            // Define color scheme:
            // Green for circular orbits in ecliptic plane
            // Red for eccentric orbits
            // Blue for highly inclined orbits
            vec3 circularEclipticColor = vec3(0.2, 0.9, 0.3);  // Bright green
            vec3 eccentricColor = vec3(1.0, 0.2, 0.15);         // Bright red
            vec3 inclinedColor = vec3(0.4, 0.6, 1.0);          // Blue

            // First blend between green (circular) and red (eccentric)
            color = mix(circularEclipticColor, eccentricColor, normalizedEccentricity);
            // Then blend towards blue based on inclination
            color = mix(color, inclinedColor, normalizedInclination * 0.7);
        }
        else if (uColorMode == 2)
        {
            // Faster logarithmic falloff with brighter near-camera appearance
            // Using a steeper logarithmic curve for more dramatic depth perception
            float logDepth = log(1.0 + vViewDistance * 2.5);
            float maxLogDepth = log(1.0 + max(uFarPlaneAU, 0.1) * 2.5);
            float normalizedDepth = clamp(logDepth / maxLogDepth, 0.0, 1.0);

            // Apply power curve for faster falloff and boost brightness near camera
            float brightness = pow(1.0 - normalizedDepth, 2.2);
            brightness = clamp(brightness * 1.3, 0.05, 1.0);
            color = vec3(brightness);
        }
        else
        {
            float dist = sqrt(x*x + y*y + z*z);
            float r = 0.5 + 0.5 * x / max(dist, 0.1);
            float g = 0.5 + 0.5 * y / max(dist, 0.1);
            float b = 0.5 + 0.5 * z / max(dist, 0.1);
            color = vec3(r, g, b);
            color = pow(color, vec3(0.75));
            float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));
            color = mix(vec3(luma), color, 1.1);
            color = clamp(color, 0.0, 1.0);
        }
        gl_FragColor = vec4(color, 1.0);
    }
</script>
<script type="x-shader/x-vertex" id="shader-bodies-vs">
    precision mediump float;

    attribute vec3 aPosition;
    attribute float aRadius;
    attribute vec3 aColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform float uPointScale;

    varying vec3 vColor;
    varying float vRadius;

    void main(void)
    {
        vec4 mvPosition = uMVMatrix * vec4(aPosition, 1.0);
        gl_Position = uPMatrix * mvPosition;

        float distance = max(0.1, -mvPosition.z);
        gl_PointSize = max(1.0, (aRadius * uPointScale) / distance);

        vColor = aColor;
        vRadius = aRadius;
    }
</script>
<script type="x-shader/x-fragment" id="shader-bodies-fs">
    precision mediump float;

    varying vec3 vColor;

    void main(void)
    {
        vec2 coord = gl_PointCoord * 2.0 - 1.0;
        float r = dot(coord, coord);
        if (r > 1.0) discard;

        float lighting = 0.35 + 0.65 * sqrt(1.0 - r);
        gl_FragColor = vec4(vColor * lighting, 1.0);
    }
</script>
</body>
</html>
